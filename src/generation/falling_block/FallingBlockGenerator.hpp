//
// Created by Qiufeng54321 on 2019-09-05.
// Copyright (C) 2019  Qiufeng54321
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

/**
 * This is the header file of the Falling Block Generator Method, derived(or implemented) from Generation.
 * Definitions in this context:
 * 		stack 				: one vertical stack of command blocks, sized 1*n*1.
 * 		generated stack		: AKA 'generation stack' or 'build stack', The stack that is generated by the command.
 * 		building process	: the process of building the whole required structure.
 *
 * The basic concept of the Falling Block Generator:
 * At the very first, NOTE that the very main principle of this generator is that the generator is based on the feature
 * 		of falling blocks, which can only become blocks when there's a block underneath, hence there should be at least
 * 		one floor of blocks (the size of the floor depends on the total size required for the command blocks and the
 * 		to-be-built area), which means, the maximum height of build stack(will be explained later in this context) will
 * 		be 254. Also, the last two blocks does NOT do the building process. Instead, they do fill-and-generate job.
 *
 * The first command block contains every command needed to build the required structure.
 * It first generates one stack(size xyz 1*n*1) initialing the process.
 * The first(bottom) command in the first stack fills the place that needs to be generated with air.
 * The commands at the middle of the first stack is not sure yet.
 * The last command initialises the build command blocks and now the building process starts.
 * The building process can be done by two methods:
 *
 * 		First Method (being called 'Co-replacing Method'):
 * 			This method requires less space for command blocks for building.
 * 			There initially will be a list(say L) showing the amount of the generation stack and their positions.
 * 			Also there will be a variable(say n) which shows the current index of the list showing the current stack.
 * 			1.The last command in the first stack first generates a stack of command blocks (the number of command blocks
 * 				in a stack can be selected by the user and it is 16 by default). The bottom of the generated stack
 * 				will be at L[n] (which, at first, n is 0, so it's the first position.)
 * 			2.The first command to the second last command in the generated stack build the blocks (which, by default,
 * 				every build stack can build 15 blocks and it can build at most 252 blocks every stack when a build stack
 * 				contains 254 blocks which is the max amount of command blocks in a build stack)
 * 			3.If n is the size of L(which means the index is at the end of the list), n will be reset to 0.
 *
 * 			4.The last command in the generated stack generates another generation stack at L[n]. Then repeat
 * 				Step 2
 *			5.If all the blocks are finished building, the final command block will try to clean all command blocks that
 *				took part in building process and also itself. Then the whole process is done.
 *
 *		Second Method (being called 'Recursive Building Method'):
 *			This method requires high computing ability and is space-costly and will build every required building blocks
 *				at once, once all the command blocks are prepared.
 *			It is similar to the first method, but it seems faster than the first method.
 *			Say that the size of the to-be-built area is 4*4*4, which is 64 block^3, and one stack is set to have 6
 *				blocks at most.
 *			The whole process can be simply described and done by only one step:
 *				The command first generates a stack of command blocks(4 command blocks for building, 2 top command
 *					blocks for cleaning and generating new stack). If the total amount of building command blocks is less
 *					than the total size of the building, the building command blocks recursively repeat step 1. Once the
 *					amount is exactly equal to the size of the building, then the command blocks will build the blocks.
 *				This method requires a high computing ability and is not recommended if your computer has low
 *					computability.
 *			This is still hypothetical and will be very likely to be implemented after the first method is implemented.
 */


#ifndef NOTEBUILDER_FALLINGBLOCKGENERATOR_HPP
#define NOTEBUILDER_FALLINGBLOCKGENERATOR_HPP

#include "Header.hpp"
#include "generation/Generator.hpp"
#include "map/StructureBlockMap.hpp"
#include "data/Position.hpp"
#include "libnbtplusplus/include/tag_list.h"

namespace InGameOperation::Generation {
	template<typename BlockMapType>
	class FallingBlockGenerator : public Generation<std::ostringstream, BlockMapType> {
	public:
		explicit FallingBlockGenerator(Option option = Option());

		void generate() override;

		void setMap(BlockMapType map) override;

		[[nodiscard]] const std::vector<Data::Position> &getPositions() const;

		void setPositions(std::vector<Data::Position> positions);

		enum Constants : unsigned int {
			STACK_FUNCTIONAL_BLOCKS = 2
		};

	protected:
		std::vector<Data::Position> positions{};

		void _generate_method_coreplacing();

		std::string _generate_next_generation_block();

		std::string _generate_next_generation_block_coreplacing(int gen_buffer, int positionIndex);

		std::string _generate_generation_stack(nbt::tag_list::iterator begin, nbt::tag_list::iterator end,
											   Data::Position target_base_pos);

	};
}

#endif //NOTEBUILDER_FALLINGBLOCKGENERATOR_HPP
